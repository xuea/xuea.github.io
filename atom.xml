<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueA</title>
  <subtitle>XueA`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuea.github.io/"/>
  <updated>2016-09-09T08:48:11.685Z</updated>
  <id>https://xuea.github.io/</id>
  
  <author>
    <name>XueA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下编译自己的JDK7</title>
    <link href="https://xuea.github.io/2016/09/09/linux%E4%B8%8B%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84JDK7/"/>
    <id>https://xuea.github.io/2016/09/09/linux下编译自己的JDK7/</id>
    <published>2016-09-09T04:58:47.000Z</published>
    <updated>2016-09-09T08:48:11.685Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习《深入理解Java虚拟机 JVM高级特性与最佳实践》，第一章介绍如何编译jdk的内容，刚开始觉得没意思，跳过了，但回过头想想“重在过程”嘛，现在有开始了。整个在ubuntu14.04系统上操作，window下编译有点难搞。<br><a id="more"></a></p>
<h3 id="下载OpenJDK源码"><a href="#下载OpenJDK源码" class="headerlink" title="下载OpenJDK源码"></a>下载OpenJDK源码</h3><p><a href="http://jdk7.java.net/" target="_blank" rel="external">下载地址</a>，请下载Source Code（源代码）<br>解压到自己的要存放的目录中</p>
<h3 id="构建编译环境"><a href="#构建编译环境" class="headerlink" title="构建编译环境"></a>构建编译环境</h3><blockquote>
<p>所有文件的保存路径等最好不要有中文，以免造成不必要的麻烦。</p>
</blockquote>
<p>编译环境需要 Bootstarp JDK 和 GCC。Bootstrap JDK 就是需要一个可用的JDK版本，在下面命令中我下载了openjdk-6的版本，如果已经有了JDK，就可以不下载了。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下载GCC相关的编译环境</span></div><div class="line">$ sudo apt-get install build-essential gawk m4 libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-dev ant libxt-dev libxtst-dev</div><div class="line"><span class="comment">#下载openjdk6</span></div><div class="line">$ sudo apt-get openjdk-6-jdk</div></pre></td></tr></table></figure></p>
<h3 id="进行编译"><a href="#进行编译" class="headerlink" title="进行编译"></a>进行编译</h3><p>terminal中进行环境变量设置：</p>
<blockquote>
<p>#语言选项，这个必须设置，否则编译好后会出现一个HashTable的NPE错<br>export LANG=C</p>
<p>#Bootstrap JDK的安装路径。必须设置。请改成自己的Bootstrap JDK路径<br>export ALT_BOOTDIR=/usr/lib/jvm/java-6-openjdk-i386/</p>
<p>#允许自动下载依赖<br>export ALLOW_DOWNLOADS=true</p>
<p>#并行编译的线程数，设置为和CPU内核数量一致即可。请设置成自己的CPU内核数<br>export HOTSPOT_BUILD_JOBS=2<br>export ALT_PARALLEL_COMPILE_JOBS=2</p>
<p>#比较本次build出来的映像与先前版本的差异。这个对我们来说没有意义，必须设置为false，否则sanity检查会报缺少先前版本JDK的映像。如果有设置dev或者DEV_ONLY=true的话这个不显式设置也行。<br>export SKIP_COMPARE_IMAGES=true</p>
<p>#使用预编译头文件，不加这个编译会更慢一些<br>export USE_PRECOMPILED_HEADER=true</p>
<p>#要编译的内容<br>export BUILD_LANGTOOLS=true<br>#export BUILD_JAXP=false<br>#export BUILD_JAXWS=false<br>#export BUILD_CORBA=false<br>export BUILD_HOTSPOT=true<br>export BUILD_JDK=true</p>
<p>#要编译的版本<br>#export SKIP_DEBUG_BUILD=false<br>#export SKIP_FASTDEBUG_BUILD=true<br>#export DEBUG_NAME=debug</p>
<p>#把它设置为false可以避开javaws和浏览器Java插件之类的部分的build。<br>BUILD_DEPLOY=false</p>
<p>#把它设置为false就不会build出安装包。因为安装包里有些奇怪的依赖，但即便不build出它也已经能得到完整的JDK映像，所以还是别build它好了。<br>BUILD_INSTALL=false</p>
<p>#编译结果所存放的路径。请设置好自己的编译结果存放路径<br>export ALT_OUTPUTDIR=/home/leo/java/myjdk</p>
<p>#这两个环境变量必须去掉，不然会有很诡异的事情发生（我没有具体查过这些“”诡异的事情”，Makefile脚本检查到有这2个变量就会提示警告“）<br>unset JAVA_HOME<br>unset CLASSPATH</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ make sanity		<span class="comment">#编译检查，最后输出“Sanity check passed”即检查通过</span></div><div class="line"><span class="comment">#此处提醒！！可以先看看避坑总结，然后再编译，可以避免一些错误</span></div><div class="line">$ make DEBUG_BINARIES=<span class="literal">true</span> 2&gt;&amp;1 | tee build.log</div></pre></td></tr></table></figure>
<h3 id="避坑总结"><a href="#避坑总结" class="headerlink" title="避坑总结"></a>避坑总结</h3><p>问题一：cc1plus: error: the “stabs” debug format cannot be used with pre-compiled headers [-Werror=deprecated]<br>问题解决：因为高版本的gcc不再支持stabs，解决办法：在make命令中加上 DEBUG_BINARIES=true</p>
<p>问题二：遇到错误Error:./gamma: relocation error: /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/amd64/libjava.so: symbol JVM_FindClassFromCaller, version SUNWprivate_1.1 not defined in file libjvm.so with link time reference<br>问题解决：修改文件hotspot/make/linux/Makefile，删掉文件中所有的  &amp;&amp; ./test_gamma  ，我的文件一共出现6次</p>
<p>问题三：Error: time is more than 10 years from present: 1136059200000<br>问题解决：将jdk源码下的jdk/src/share/classes/java/util/CurrencyData.properties里面出现的时间全部改为10年内的时间。<br>例如：TR=TRL;2004-12-31-22-00-00;TRY  改为   TR=TRL;2014-12-31-22-00-00;TRY</p>
<h3 id="编译成功"><a href="#编译成功" class="headerlink" title="编译成功"></a>编译成功</h3><p>出现如下字样，表示就编译成功了。</p>
<blockquote>
<p>#– Build times ———-<br>Target all_product_build<br>Start 2016-09-09 09:46:45<br>End   2016-09-09 09:56:22<br>00:00:03 corba<br>00:00:10 hotspot<br>00:00:02 jaxp<br>00:00:03 jaxws<br>00:09:17 jdk<br>00:00:02 langtools<br>00:09:37 TOTAL<br>-————————</p>
</blockquote>
<p>此时，进入编译结果存放目录，进入 j2sdk-image 目录，这就是一个完整的JDK编译结果了。<br>输入命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./java -version</div><div class="line">openjdk version <span class="string">"1.7.0-internal"</span></div><div class="line">OpenJDK Runtime Environment (build 1.7.0-internal-leo_2016_09_09_09_32-b00)</div><div class="line">OpenJDK Server VM (build 24.0-b56, mixed mode)</div></pre></td></tr></table></figure></p>
<p>很爽吧，里面还带有自己的机器名(leo)，还有编译时间。此时，拿着这个jdk就可以全局使用了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ sudo gedit ~/.bashrc</div><div class="line"><span class="comment"># 尾部加上</span></div><div class="line"><span class="built_in">export</span> JAVA_HOME=/home/leo/java/myjdk/j2sdk-image </div><div class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </div><div class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></div><div class="line"></div><div class="line">$ <span class="built_in">source</span> ~/.bashrc</div><div class="line">$ java -version			<span class="comment">#可以到处使用了</span></div></pre></td></tr></table></figure></p>
<p>最后，提醒一下，OpenJDK可能有很多内容并不时候生产环境使用，生产环境最好还是使用Oracle JDK或者Sun JDK。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习《深入理解Java虚拟机 JVM高级特性与最佳实践》，第一章介绍如何编译jdk的内容，刚开始觉得没意思，跳过了，但回过头想想“重在过程”嘛，现在有开始了。整个在ubuntu14.04系统上操作，window下编译有点难搞。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://xuea.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xuea.github.io/tags/Java/"/>
    
      <category term="jdk" scheme="https://xuea.github.io/tags/jdk/"/>
    
      <category term="ubuntu" scheme="https://xuea.github.io/tags/ubuntu/"/>
    
      <category term="OpenJDK" scheme="https://xuea.github.io/tags/OpenJDK/"/>
    
  </entry>
  
  <entry>
    <title>Java并发：CAS算法探秘</title>
    <link href="https://xuea.github.io/2016/09/05/Java%E5%B9%B6%E5%8F%91%EF%BC%9ACAS%E7%AE%97%E6%B3%95%E6%8E%A2%E7%A7%98/"/>
    <id>https://xuea.github.io/2016/09/05/Java并发：CAS算法探秘/</id>
    <published>2016-09-05T15:02:30.000Z</published>
    <updated>2016-09-07T07:04:12.545Z</updated>
    
    <content type="html"><![CDATA[<p>CAS（Compare and swap）是并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。是对jdk1.5以前仅有悲观锁synchronouse的一种实现补充，CAS属于乐观锁范畴的算法，jdk中越来越多的并发算法都基于CAS算法实现。<br><a id="more"></a></p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观者与乐观者的做事方式完全不一样，悲观者的人生观是一件事情我必须要百分之百完全控制才会去做，否则就认为这件事情一定会出问题；而乐观者的人生观则相反，凡事不管最终结果如何，他都会先尝试去做，大不了最后不成功。这就是悲观锁与乐观锁的区别，悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据。</p>
<p>JDK1.5之前都是靠synchronized关键字保证同步的，线程的挂起和恢复比较频繁，开销比较大。<br>独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>
<h2 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h2><blockquote>
<p>CAS（Compareand Swap，比较并交换）算法涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。</p>
</blockquote>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：</p>
<ul>
<li>乐观锁只能保证一个共享变量的原子操作。如果要求多个变量进行原子操作，将会力不从心，而独占锁没这个问题。</li>
<li>CAS尝试失败后会再次尝试，直到成功为止，如果尝试次数过多，对CPU的开销反而会更大。</li>
<li>ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。</li>
</ul>
<p>CAS乐观锁是对悲观锁的改进，虽然它也有缺点，但它确实已经成为提高并发性能的主要手段，而且jdk中的并发包也大量使用基于CAS的乐观锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CAS（Compare and swap）是并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。是对jdk1.5以前仅有悲观锁synchronouse的一种实现补充，CAS属于乐观锁范畴的算法，jdk中越来越多的并发算法都基于CAS算法实现。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://xuea.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xuea.github.io/tags/Java/"/>
    
      <category term="并发" scheme="https://xuea.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CAS" scheme="https://xuea.github.io/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat指定JDK版本运行</title>
    <link href="https://xuea.github.io/2016/09/01/Tomcat%E6%8C%87%E5%AE%9AJDK%E7%89%88%E6%9C%AC%E8%BF%90%E8%A1%8C/"/>
    <id>https://xuea.github.io/2016/09/01/Tomcat指定JDK版本运行/</id>
    <published>2016-09-01T03:08:48.000Z</published>
    <updated>2016-09-01T12:57:08.757Z</updated>
    
    <content type="html"><![CDATA[<p>业务需求：一台服务器centos默认jdk版本是1.6，跑了两个服务tomcat服务：<br>业务一：占用8080端口，需要jdk6运行，是事先部署好的；<br>业务二：占用8180端口，需要jdk7运行，是将要部署的。<br>现在需要部署业务二，就会出现报错，怎么办？<br><a id="more"></a></p>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>业务二的项目部署好之后，启动项目，出现如下报错：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">java.lang.UnsupportedClassVersionError: org/springframework/web/filter/DelegatingFilterProxy : Unsupported major.minor version 51.0 (unable to load class org.springframework.web.filter.DelegatingFilterProxy)</div><div class="line">	at org.apache.catalina.loader.WebappClassLoader.findClassInternal(WebappClassLoader.java:2858)</div><div class="line">	at org.apache.catalina.loader.WebappClassLoader.findClass(WebappClassLoader.java:1159)</div><div class="line">	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1647)</div><div class="line">	at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1526)</div><div class="line">	at org.apache.catalina.startup.WebAnnotationSet.loadClassAnnotation(WebAnnotationSet.java:145)</div><div class="line">	at org.apache.catalina.startup.WebAnnotationSet.loadApplicationFilterAnnotations(WebAnnotationSet.java:84)</div><div class="line">	at org.apache.catalina.startup.WebAnnotationSet.loadApplicationAnnotations(WebAnnotationSet.java:57)</div><div class="line">	at org.apache.catalina.startup.ContextConfig.applicationAnnotationsConfig(ContextConfig.java:294)</div><div class="line">	at org.apache.catalina.startup.ContextConfig.start(ContextConfig.java:1047)</div><div class="line">	at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:265)</div><div class="line">	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:142)</div><div class="line">	at org.apache.catalina.core.StandardContext.start(StandardContext.java:4616)</div><div class="line">	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:799)</div><div class="line">	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:779)</div><div class="line">	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:583)</div><div class="line">	at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1079)</div><div class="line">	at org.apache.catalina.startup.HostConfig.deployDirectories(HostConfig.java:1002)</div><div class="line">	at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:506)</div><div class="line">	at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1317)</div><div class="line">	at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:324)</div><div class="line">	at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:142)</div><div class="line">	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1065)</div><div class="line">	at org.apache.catalina.core.StandardHost.start(StandardHost.java:822)</div><div class="line">	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1057)</div><div class="line">	at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:463)</div><div class="line">	at org.apache.catalina.core.StandardService.start(StandardService.java:525)</div><div class="line">	at org.apache.catalina.core.StandardServer.start(StandardServer.java:754)</div><div class="line">	at org.apache.catalina.startup.Catalina.start(Catalina.java:595)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:597)</div><div class="line">	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)</div><div class="line">	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)</div><div class="line">2016-8-29 9:55:13 org.apache.coyote.http11.Http11AprProtocol start</div></pre></td></tr></table></figure></p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>jdk的版本问题，如上描述，业务二需要最低jdk版本为7</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>下载centos使用的 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="external">jdk7</a>，我下载出来的文件名为：<br>jdk-7u45-linux-x64.tar.gz</li>
<li><p>解压到某个目录下面并把源包删除</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar xvf jdk-7u45-linux-x64.tar.gz</div><div class="line">$ rm jdk-7u45-linux-x64.tar.gz</div></pre></td></tr></table></figure>
<p>此时，进入到jdk7目录下的bin目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ java -version		<span class="comment">#返回的版本号是1.6，因为这是全局的jdk</span></div><div class="line">$ ./java -version	<span class="comment">#返回的版本号是1.7，因为这是当前目录下的jdk</span></div></pre></td></tr></table></figure>
</li>
<li><p>配置8180端口的tomcat<br>在catalina.sh文件和setclasspath.sh文件的头部都加上指定jdk的地址(jdk路径根据自己的配置来变更)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/app/jdk7</div><div class="line"><span class="built_in">export</span> JRE_HOME=/usr/<span class="built_in">local</span>/app/jdk7/jre</div></pre></td></tr></table></figure>
</li>
<li><p>如果出现端口冲突问题，请配置好自己tomcat下的server.xml文件，以下是一个示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;    ----&gt;    &lt;Server port=<span class="string">"8195"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</div><div class="line"></div><div class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span> connectionTimeout=<span class="string">"20000"</span> redirectPort=<span class="string">"8443"</span> /&gt;    ----&gt;    &lt;Connector port=<span class="string">"8180"</span> protocol=<span class="string">"HTTP/1.1"</span>  maxThreads=<span class="string">"150"</span> minSpareThreads=<span class="string">"25"</span> maxSpareThreads=<span class="string">"75"</span> <span class="built_in">enable</span>Lookups=<span class="string">"false"</span> redirectPort=<span class="string">"8443"</span> acceptCount=<span class="string">"100"</span> debug=<span class="string">"0"</span> connectionTimeout=<span class="string">"20000"</span> <span class="built_in">disable</span>UploadTimeout=<span class="string">"true"</span> /&gt;</div><div class="line"></div><div class="line">&lt;Connector port=<span class="string">"8009"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;    ----&gt;    &lt;Connector port=<span class="string">"8199"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</div><div class="line"></div><div class="line">&lt;Host name=<span class="string">"localhost"</span>  appBase=<span class="string">"webapps"</span> unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span> xmlValidation=<span class="string">"false"</span> xmlNamespaceAware=<span class="string">"false"</span>&gt;    ----&gt;    &lt;Host name=<span class="string">"10.10.3.54"</span>  appBase=<span class="string">"webapps"</span> unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span> xmlValidation=<span class="string">"false"</span> xmlNamespaceAware=<span class="string">"false"</span> &gt;&lt;Context path=<span class="string">""</span> docBase=<span class="string">"ROOT"</span> reloadable=<span class="string">"true"</span>&gt;&lt;/Context&gt;&lt;/Host&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>启动tomcat，成功</p>
</li>
</ol>
<h2 id="扩展：Eclipse中tomcat指定jdk来启动"><a href="#扩展：Eclipse中tomcat指定jdk来启动" class="headerlink" title="扩展：Eclipse中tomcat指定jdk来启动"></a>扩展：Eclipse中tomcat指定jdk来启动</h2><p>首先打开 window–》Preferences</p>
<ol>
<li>查看eclipse中现有的jdk版本，如下图，如果没有自己想要的版本，请在安装好之后，点击add添加进来：<br><img src="http://img.stepbystep.top/blog/20160901/add_jdk.png" alt="查看eclipse中现有的jdk版本"></li>
<li>搜索tomcat，出现如下图，更改JDK的版本即可，记得保存<br><img src="http://img.stepbystep.top/blog/20160901/choose_jdk.png" alt="为tomcat选择固定的jdk版本"></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;业务需求：一台服务器centos默认jdk版本是1.6，跑了两个服务tomcat服务：&lt;br&gt;业务一：占用8080端口，需要jdk6运行，是事先部署好的；&lt;br&gt;业务二：占用8180端口，需要jdk7运行，是将要部署的。&lt;br&gt;现在需要部署业务二，就会出现报错，怎么办？&lt;br&gt;
    
    </summary>
    
      <category term="tomcat" scheme="https://xuea.github.io/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="https://xuea.github.io/tags/tomcat/"/>
    
      <category term="jdk" scheme="https://xuea.github.io/tags/jdk/"/>
    
      <category term="异常处理" scheme="https://xuea.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux复习--命令总结</title>
    <link href="https://xuea.github.io/2016/08/20/linux%E5%A4%8D%E4%B9%A0-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://xuea.github.io/2016/08/20/linux复习-命令总结/</id>
    <published>2016-08-20T02:13:55.000Z</published>
    <updated>2016-09-07T10:29:28.911Z</updated>
    
    <content type="html"><![CDATA[<p>linux操作系统在开发部署过程中太常用了，一个优秀的开发者肯定会熟练使用它的。<br><a id="more"></a></p>
<h2 id="linux引子"><a href="#linux引子" class="headerlink" title="linux引子"></a>linux引子</h2><p>Linux确切的是指一个操作系统中的内核，它源于Unix，linux操作系统是指采用linux内核的GNU操作系统。<br>在1991年，由芬兰赫尔辛基大学的学生Linus B. Torvolds首创。</p>
<p>linux的发行版本，比较流行的有下列：Debian，红帽（redhat）、ubuntu、Suse、Open Suse、Mandriva（原Mandrake）、CentOS、fedora等，国内比较著名的有红旗linux。</p>
<p>linux/unix基本思想与原则：</p>
<ul>
<li>一切皆文件：系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件 </li>
<li>K.I.S.S (Keep it Simple Stupid)：保持简单傻瓜化，简单，易学易用，足够强壮</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="首先，如何寻求帮助？"><a href="#首先，如何寻求帮助？" class="headerlink" title="首先，如何寻求帮助？"></a>首先，如何寻求帮助？</h3><ul>
<li>man：linux有句话，“有问题，找男人”，即找man命令，man其实是manual(操作说明)的简写。</li>
<li>--help：是某个命令自带的简单有用的帮助文档，这个文档简单有用。</li>
<li>info：是Linux下info格式的帮助指令，可以像浏览网页一样在各个节点中跳转，相比于man更容易查看。下面是进入info命令里面后会用到的快捷键：<blockquote>
<p>?键：它就会显示info的常用快捷键。<br>N键：显示（相对于本节点的）下一节点的文档内容。<br>P键：显示（相对于本节点的）前一节点的文档内容。<br>U键：进入当前命令所在的主题。<br>M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了。<br>G键：敲G键后输入主题名称，进入该主题。<br>L键：回到上一个访问的页面。<br>SPACE键：向前滚动一页。<br>BACKUP或DEL键：向后滚动一页。<br>Q：退出info。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ man ls	#查看ls命令的操作说明。进入里面按q是退出</div><div class="line">$ info ls	#查看ls命令的操作说明，info格式的。</div><div class="line">$ ls --help	#查看ls命令的简单操作说明</div></pre></td></tr></table></figure>
<h3 id="退出当前命令"><a href="#退出当前命令" class="headerlink" title="退出当前命令"></a>退出当前命令</h3><p>常用：ctrl+c<br>进入某个命令后，可能用：q</p>
<h3 id="tab补全"><a href="#tab补全" class="headerlink" title="tab补全"></a>tab补全</h3><p>这个可能是大家最喜欢的操作之一了</p>
<ul>
<li>未输入状态下连按两次 Tab 列出所有可用命令</li>
<li>已输入部分命令名或文件名，按 Tab 进行自动补全</li>
</ul>
<h3 id="管道符-和重定向符-gt"><a href="#管道符-和重定向符-gt" class="headerlink" title="管道符 | 和重定向符 &gt;"></a>管道符 | 和重定向符 &gt;</h3><p>在linux中，任何一条命令都会经过这样一个过程：</p>
<blockquote>
<p>一个命令执行了：<br>先有一个标准输入：输入可以从键盘，也可以从文件得到<br>命令执行完成：成功了，会把成功结果输出到屏幕：standard output(标准输出)默认是屏幕<br>命令执行有错误：会把错误也输出到屏幕上面：standard error(标准错误输出)默认也是指的屏幕</p>
</blockquote>
<p>linux shell下常用输入输出操作符是：</p>
<ol>
<li>标准输入   (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； /dev/stdin -&gt; /proc/self/fd/0   0代表：/dev/stdin </li>
<li>标准输出   (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； /dev/stdout -&gt; /proc/self/fd/1  1代表：/dev/stdout</li>
<li>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ； /dev/stderr -&gt; /proc/self/fd/2 2代表：/dev/stderr</li>
</ol>
<p>管道符是将上一个命令的标准输出作为下一个命令的标准输入<br>重定向符是可以将标准输入、标准输出、标准错误输出改变到其他文件或设备<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep mongod		<span class="comment">#ps -ef是查看当前运行的进程，grep是正则过滤。组合起来的意思是查看当前包含"mongod"字符的进程信息</span></div><div class="line">$ <span class="built_in">echo</span> <span class="string">"hello"</span>			<span class="comment">#在屏幕(默认输出)上输出hello</span></div><div class="line">$ <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; a.txt		<span class="comment">#将hello输入到a.txt文件中，屏幕上不会显示</span></div><div class="line">$ <span class="built_in">echo</span> <span class="string">"hello2"</span> &gt;&gt; a.txt	<span class="comment">#将hello2追加到a.txt文件中</span></div><div class="line">$ cat b.txt 2&gt; error.txt	<span class="comment">#查看b.txt文件，如果出现错误，将错误信息输入到 error.txt中。此时因为b.txt文件不存在，会出现错误，error.txt中有：cat: b.txt: No such file or directory</span></div><div class="line">$ ls -al  1&gt; list.txt   2&gt; list.err		<span class="comment">#将显示的数据，正确的输出到 list.txt 错误的数据输出到 list.err</span></div><div class="line">$ ls -al 1&gt; list.txt 2&gt; &amp;1			<span class="comment">#将显示的数据，不论正确或错误均输出到 list.txt 当中</span></div><div class="line">$ ls -al 1&gt; list.txt 2&gt; /dev/null		<span class="comment">#将显示的数据，正确的输出到 list.txt 错误的数据则予以丢弃！ /dev/null ，可以说成是linux文件的黑洞装置。为空，即不保存。</span></div></pre></td></tr></table></figure></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="ls-列出目录内容"><a href="#ls-列出目录内容" class="headerlink" title="ls:列出目录内容"></a>ls:列出目录内容</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">$ ls <span class="_">-a</span>		<span class="comment">#显示当前目录下的所有内容，包括隐藏的文件内容，linux系统中以.开头的文件都是隐藏的文件或文件夹</span></div><div class="line">$ ls <span class="_">-l</span>		<span class="comment">#详细地显示每一个文件或文件夹内容</span></div><div class="line">$ ll		<span class="comment">#同 ls -l 功能一致，在某些操作系统可能不支持</span></div></pre></td></tr></table></figure>
<blockquote>
<p>详细说明一下“ls -l”命令的结果，假如命令返回如下内容：<br>drwx------ 2 Guest users 1024 Nov 21 21:05 Mail　　<br>-rwxr-xr-x 1 root bin 5013 Aug 15 9:32 uname*　　<br>每一列从左到右依次是：文件属性，连接数，拥有者，所在的group，文件大小，建档日期或者最后一次修改的时间，文件名<br>其中 文件属性 这一列共有十个字符：<br>第一个字符为文件类型信息：-指普通文件，d指目录文件，l指链接文件，b指块设备文件，c指字符设备文件，p指管道文件<br>第二到第十个字符中 每三个字符为一组，第一组表示文件所有者权限，第二组表示同组人权限，第三个表示他人权限。r、w、x分别代表可读，可写，可执行权限。</p>
</blockquote>
<h3 id="pwd：显示当前文件路径"><a href="#pwd：显示当前文件路径" class="headerlink" title="pwd：显示当前文件路径"></a>pwd：显示当前文件路径</h3><h3 id="basename：获取文件名"><a href="#basename：获取文件名" class="headerlink" title="basename：获取文件名"></a>basename：获取文件名</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ basename /etc/httpd/httpd.conf	<span class="comment">#返回httpd.conf</span></div></pre></td></tr></table></figure>
<h3 id="dirname：获取路径名"><a href="#dirname：获取路径名" class="headerlink" title="dirname：获取路径名"></a>dirname：获取路径名</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dirname /etc/httpd/httpd.conf		<span class="comment">#返回/etc/httpd</span></div></pre></td></tr></table></figure>
<h3 id="cd：跳转系统路径"><a href="#cd：跳转系统路径" class="headerlink" title="cd：跳转系统路径"></a>cd：跳转系统路径</h3><p>基本用法就是： cd path<br>path 有绝对路径和相对路径之分，绝对路径强调从 / 起，一直到所在路径。相对路径则相对于当前路径来说，假设当前的目录有etc 文件夹（绝对路径应为 /home/username/etc），如果直接 cd etc 则进入此文件夹，但若是 cd /etc/ 则是进入系统 etc ，多琢磨一下就可以理解了。另外在 Linux 中， . 代表当前目录， .. 代表上级目录，因此返回上级目录可以 cd ..<br>注意配合tab补全使用，方便准确，注意区分大小写。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /		<span class="comment">#进入根目录</span></div><div class="line">$ <span class="built_in">cd</span> usr	<span class="comment">#进入当前目录下的usr目录</span></div><div class="line">$ <span class="built_in">cd</span> ..		<span class="comment">#返回上级目录</span></div></pre></td></tr></table></figure></p>
<h3 id="file：查看文件信息"><a href="#file：查看文件信息" class="headerlink" title="file：查看文件信息"></a>file：查看文件信息</h3><p>普通文件，压缩文件，连接文件都有不同的结果，可以都试试<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ file a.txt	<span class="comment">#查看文件的类型，编码等信息</span></div><div class="line">$ file -i a.txt	<span class="comment">#查看文件的mime类型</span></div></pre></td></tr></table></figure></p>
<h3 id="cat：查看全部文件"><a href="#cat：查看全部文件" class="headerlink" title="cat：查看全部文件"></a>cat：查看全部文件</h3><p>如果文件比较大，使用就不方便<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat catlina.out		<span class="comment">#查看catline.out文件内容</span></div><div class="line">$ cat -n catlina.out		<span class="comment">#查看catline.out文件内容，显示行号</span></div></pre></td></tr></table></figure></p>
<h3 id="more：翻页查看文件"><a href="#more：翻页查看文件" class="headerlink" title="more：翻页查看文件"></a>more：翻页查看文件</h3><p>让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按Q键停止显示。</p>
<h3 id="less：翻页查看文件"><a href="#less：翻页查看文件" class="headerlink" title="less：翻页查看文件"></a>less：翻页查看文件</h3><p>空格键：向下翻页<br>[pagedown]：向下翻页<br>[pageup]：向上翻页<br>/字符串：向下搜索字符串<br>?字符串：向上搜索字符串<br>n：重复前一个搜索，向上继续搜<br>N：重复前一个搜索，向下继续搜<br>q：退出less</p>
<h3 id="head：查看文件的前面几行"><a href="#head：查看文件的前面几行" class="headerlink" title="head：查看文件的前面几行"></a>head：查看文件的前面几行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ head catlina.out		<span class="comment">#默认查看catlina.out文件的前十行内容</span></div><div class="line">$ head -n 20 catlina.out	<span class="comment">#查看catlina.out文件的前二十行内容</span></div><div class="line">$ head -n -20 catlina.out	<span class="comment">#查看catlina.out文件除去最后二十行之前的内容</span></div></pre></td></tr></table></figure>
<h3 id="tail：查看文件的尾部几行"><a href="#tail：查看文件的尾部几行" class="headerlink" title="tail：查看文件的尾部几行"></a>tail：查看文件的尾部几行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ tail catlina.out		<span class="comment">#默认查看catlina.out文件的最后十行内容</span></div><div class="line">$ tail -n 20 catlina.out	<span class="comment">#查看catlina.out文件的最后二十行内容</span></div><div class="line">$ tail -n -20 catlina.out	<span class="comment">#查看catlina.out文件的最后二十行内容，没写错，和上面效果一样</span></div><div class="line">$ tail -n +20 catlina.out	<span class="comment">#查看catlina.out文件的二十行开始后的所有内容</span></div><div class="line">$ tail <span class="_">-f</span> catlina.out		<span class="comment">#可以实时查看catlina.out文件追加的内容，追踪实时日志会常用到</span></div><div class="line"><span class="comment">#来个复杂的：</span></div><div class="line">$ tail +4 catlina.out | head -n 39	<span class="comment">#查看catlina.out从第四行开始，共39行内容</span></div></pre></td></tr></table></figure>
<h3 id="mkdir：创建文件夹"><a href="#mkdir：创建文件夹" class="headerlink" title="mkdir：创建文件夹"></a>mkdir：创建文件夹</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir a		<span class="comment">#创建1文件夹</span></div><div class="line">$ mkdir -p a/b/c	<span class="comment">#创建c文件夹，如果b，a文件夹不存在，会自动创建而不报错</span></div><div class="line">$ mkdir -m 777 a	<span class="comment">#创建一个权限为777的a文件夹，777是管理权限的值。</span></div></pre></td></tr></table></figure>
<blockquote>
<p>此处来详细解释一下权限值是怎么来的：<br>“ls -l” 命令中，第一列中除去第一个字母，剩下第二个到第十个字母就是本文件或者文件夹的权限标志了。<br>假如一个文件权限为”rwxrwxrwx”，表示 文件所有者 拥有可读、可写、可执行权限，同组人拥有可读、可写、可执行权限，其他人拥有 可读、可写、可执行权限。<br>r、w、x分别记为数字4，2，1，就像二进制一样。那么”rwxrwxrwx”权限就可以记为 777，这也是一个文件所提供的最高权限了。<br>假如你想赋予一个文件”rwxr-xr-x”的权限，那么权限值给出 755 即可。<br>假如你想赋予一个文件”rw-r–r–”的权限，那么权限值给出 644 即可。</p>
</blockquote>
<h3 id="touch：创建文件"><a href="#touch：创建文件" class="headerlink" title="touch：创建文件"></a>touch：创建文件</h3><p>另外可以重新设定文件的时间戳，感觉并不太常用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ touch test.txt			<span class="comment">#创建一个test.txt文件</span></div><div class="line">$ touch -r log.log <span class="built_in">log</span>2012.log		<span class="comment">#更新log.log的时间和log2012.log时间戳相同</span></div><div class="line">$ touch -t 201211142234.50 log.log	<span class="comment">#设定log.log的时间戳</span></div></pre></td></tr></table></figure></p>
<h3 id="rm：删除文件或文件夹"><a href="#rm：删除文件或文件夹" class="headerlink" title="rm：删除文件或文件夹"></a>rm：删除文件或文件夹</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rm log.log	<span class="comment">#删除log.log文件，如果文件非空，会提示是否删除，按y则删除完成</span></div><div class="line">$ rm <span class="_">-f</span> log.log	<span class="comment">#强制删除log.log文件，系统不会提示</span></div><div class="line">$ rm -rf <span class="built_in">test</span>	<span class="comment">#强制递归删除test文件夹及文件夹下的内容，系统不会提示</span></div></pre></td></tr></table></figure>
<h3 id="rmdir：删除空文件夹"><a href="#rmdir：删除空文件夹" class="headerlink" title="rmdir：删除空文件夹"></a>rmdir：删除空文件夹</h3><p>只能删除空目录，非空目录还得靠rm命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rmdir <span class="built_in">test</span>			<span class="comment">#删除test目录，如果test下有内容，会提示无法删除</span></div><div class="line">$ rmdir -p <span class="built_in">test</span>1/<span class="built_in">test</span>2		<span class="comment">#删除test2目录，如果test1此时也成了空目录的话，test1也会被删除。命令等于 "rmdir test1/test2 test1"</span></div></pre></td></tr></table></figure></p>
<h3 id="cp：复制"><a href="#cp：复制" class="headerlink" title="cp：复制"></a>cp：复制</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cp file file2			<span class="comment">#将file复制到file2</span></div><div class="line">$ cp -u -v file file2		<span class="comment">#将file复制到file2，-u只有源文件相比目标文件有变动才复制，-v显示执行过程</span></div><div class="line">$ cp file1 dir1			<span class="comment">#将file1赋值到目录dir1下面</span></div><div class="line">$ cp file1 file2 file3 dir1	<span class="comment"># 将file1,file2,file3赋值到目录dir1下面</span></div><div class="line">$ cp -r dir1 dir2		<span class="comment">#将dir1目录及内容复制到dir2下面</span></div></pre></td></tr></table></figure>
<h3 id="mv：移动，重命名"><a href="#mv：移动，重命名" class="headerlink" title="mv：移动，重命名"></a>mv：移动，重命名</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mv <span class="built_in">source</span>  folder		<span class="comment">#将 source 移动到 folder 下，完成后则为 folder/source</span></div><div class="line">$ mv <span class="built_in">source</span> dest		<span class="comment">#在 dest 不为目录的前提下，重命名 source 为 dest</span></div></pre></td></tr></table></figure>
<h3 id="grep：文本搜索"><a href="#grep：文本搜索" class="headerlink" title="grep：文本搜索"></a>grep：文本搜索</h3><p>该命令通常和其他命令联合使用，值得牢记<br>grep参数:</p>
<blockquote>
<p>-c：只输出匹配行的计数。<br>-I：不区分大 小写(只适用于单字符)。<br>-h：查询多文件时不显示文件名。<br>-l：查询多文件时只输出包含匹配字符的文件名。<br>-n：显示匹配行及 行号。<br>-s：不显示不存在或无匹配文本的错误信息。<br>-v：显示不包含匹配文本的所有行。</p>
</blockquote>
<p>正则表达式主要参数:</p>
<blockquote>
<p>\： 忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>.：所有的单个字符<br>*：有字符，长度可以为0</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ grep <span class="string">'test'</span> log.log	<span class="comment">#显示log.log文件中包含test的行</span></div><div class="line">$ grep <span class="string">'test'</span> aa bb cc	<span class="comment">#显示aa、bb、cc文件中包含test的行</span></div><div class="line">$ grep <span class="string">'[a-z]\&#123;5\&#125;'</span> aa	<span class="comment">#显示aa文件中包含每个字符串有5个连续小写字符的字符串的行，&#123;&#125;要转义</span></div><div class="line">$ grep <span class="string">'123'</span> -r *	<span class="comment">#查询当前目录下(*)包含所有子文件(-r)，所有包含123的行</span></div></pre></td></tr></table></figure>
<h3 id="find：查文件"><a href="#find：查文件" class="headerlink" title="find：查文件"></a>find：查文件</h3><p>最常用，实际搜寻硬盘查询文件名称，实时精确，但稍微较慢<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</span></div><div class="line">$ find / -name <span class="string">"mongo"</span>		<span class="comment">#全盘查找文件名为mongo的文件</span></div><div class="line">$ find . -name <span class="string">"mongo"</span>		<span class="comment">#全盘当前目录下文件名为mongo的文件</span></div><div class="line">$ find / -name <span class="string">"mongo*"</span>		<span class="comment">#全盘查找包含文件名为mongo的文件</span></div><div class="line">$ find / -iname <span class="string">"mongo*"</span>	<span class="comment">#全盘查找包含文件名为mongo的文件，不区分大小写</span></div></pre></td></tr></table></figure></p>
<h3 id="whereis：查文件"><a href="#whereis：查文件" class="headerlink" title="whereis：查文件"></a>whereis：查文件</h3><p>whereis命令只能用于搜索程序名，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ whereis ls</div></pre></td></tr></table></figure></p>
<h3 id="which：查文件"><a href="#which：查文件" class="headerlink" title="which：查文件"></a>which：查文件</h3><p>查看可执行文件的位置<br>which是通过 PATH环境变量 到该路径内查找可执行文件，所以基本的功能是寻找可执行文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span>		<span class="comment">#输出当前环境变量</span></div><div class="line">$ <span class="built_in">which</span> ls		<span class="comment">#输出ls命令的位置</span></div></pre></td></tr></table></figure></p>
<h3 id="locate：查文件"><a href="#locate：查文件" class="headerlink" title="locate：查文件"></a>locate：查文件</h3><p>配合数据库查看文件位置，不是实时查找，数据库更新每天更新一次<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ updatedb		<span class="comment">#更新文件位置数据库</span></div><div class="line">$ locate passwd		<span class="comment">#查找文件名包含passwd文件o</span></div><div class="line">$ locate -n 10 passwd	<span class="comment">#查找文件名包含passwd文件，只显示前10个</span></div></pre></td></tr></table></figure></p>
<h3 id="ln：创建链接"><a href="#ln：创建链接" class="headerlink" title="ln：创建链接"></a>ln：创建链接</h3><p>如同windows下的快捷方式一样，用到相同文件时，我们不需要复制一遍，只需要连接link一下即可。<br>软连接：1.软链接，以路径的形式存在；2.软链接可以 跨文件系统 ，硬链接不可以；3.软链接可以对一个不存在的文件名进行链接；4.软链接可以对目录进行链接<br>硬连接：1.硬链接，以文件副本的形式存在。但不占用实际空间；2.不允许给目录创建硬链接；3.硬链接只有在同一个文件系统中才能创建<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ln <span class="_">-s</span> <span class="built_in">log</span> link_<span class="built_in">log</span>		<span class="comment">#为log文件创建了一个link_log的软连接，常用</span></div><div class="line">$ ln <span class="built_in">log</span> link_<span class="built_in">log</span>		<span class="comment">#为log文件创建了一个link_log的硬连接</span></div></pre></td></tr></table></figure></p>
<h3 id="nano：编辑文件"><a href="#nano：编辑文件" class="headerlink" title="nano：编辑文件"></a>nano：编辑文件</h3><p>使用方法：nano 文件名<br>如果你要保存所做的修改，按下Ctrl+O。想要退出，按下Ctrl+X。如果你退出前没有保存所做的修改，它会提示你是否要保存。如果不要，请按N，反之，则按Y。然后它会让你确认要保存的文件名，确认或修改后按Enter即可。</p>
<h3 id="vi：编辑文件"><a href="#vi：编辑文件" class="headerlink" title="vi：编辑文件"></a>vi：编辑文件</h3><p>这个也是用来编辑文件的，是编辑神器vim的母体，使用较为麻烦，此处不说明。</p>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ halt</div><div class="line">$ poweroff</div><div class="line">$ shutdown -h now</div><div class="line">$ shutdown -h 10 	<span class="comment">#10分钟后关机，可以用shutdown -c 取消</span></div></pre></td></tr></table></figure>
<h3 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ reboot</div><div class="line">$ shutdown -r now</div><div class="line">$ shutdown -r 10	<span class="comment">#10分钟后重启</span></div><div class="line">$ shutdown -r 20:35	<span class="comment">#时间为20:35重启</span></div></pre></td></tr></table></figure>
<h3 id="uname：系统信息"><a href="#uname：系统信息" class="headerlink" title="uname：系统信息"></a>uname：系统信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ uname				<span class="comment">#内核名</span></div><div class="line">$ uname <span class="_">-a</span>			<span class="comment">#详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称</span></div></pre></td></tr></table></figure>
<h3 id="top：任务管理器"><a href="#top：任务管理器" class="headerlink" title="top：任务管理器"></a>top：任务管理器</h3><p>输入 top 后：<br><img src="http://img.stepbystep.top/blog/20160820/top.png" alt="top命令截图"></p>
<ul>
<li>前五行是系统整体的统计信息</li>
</ul>
<ol>
<li>第一行：<br>信息如下：top - 21\:50\:54 up 48 days, 16:16,  1 user,  load average: 0.00, 0.01, 0.05<br>意义：本行同 uptime 输出结果一致，是时间和任务队列的信息。<br>21\:50\:54 是 当前时间，up 48 days，16:16 表示服务器已经运行的时间，1 user表示当前登录的用户数，load average: 0.00, 0.01, 0.05  表示系统负载，即任务队列的平均长度， 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。</li>
<li>第二行：<br>信息如下：Tasks:  12 total,   1 running,  11 sleeping,   0 stopped,   0 zombie<br>意义：本行主要是任务信息。分别代表总共任务数，正在运行的任务数，睡眠的任务数，停止的任务数，僵尸任务数</li>
<li>第三行：<br>信息如下：Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st<br>意义：本行主要是cpu信息。从左到右分别是：“用户空间占用CPU百分比”、“内核空间占用CPU百分比”、“用户空间内改变过优先级的进程占用CPU百分比”、“空闲CPU百分比”、“等待输入输出CPU时间百分比”、“CPU服务于硬件中断所耗费的时间总额”、“CPU服务软中断所耗费的时间总额”、“Steal Time”</li>
<li>第四行：<br>信息如下：Mem:    262144k total,   149204k used,   112940k free,        0k buffers<br>意义：本行主要是内存使用情况。从左到右依次是：“物理内存总量”、“已使用的物理内存”、“空闲物理内存”、“内核缓存内存量”</li>
<li>第五行：<br>信息如下：Swap:   131072k total,    23308k used,   107764k free,    34024k cached<br>意义：本行主要是交换区(虚拟内存)的使用情况。从左到右一次是：“交换区总量”、“已使用交互区总量”、“空闲交换区总量”、“缓冲的交换区总量”</li>
</ol>
<ul>
<li><p>接下来是一直变动的进程信息<br>标志：PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>意义：“进程ID”、“进程所有者”、“优先级”、“nice值，负值表示高优先级，正值表示低优先级”、“进程使用的虚拟内存总量”、“进程使用的、未被换出的物理内存大小”、“共享内存大小”、“进程状态”、“上次更新到现在的CPU时间占用百分比”、“进程使用的物理内存百分比”、“进程使用CPU总时间”、“命令名、命令行”</p>
</li>
<li><p>简单使用<br>h或者? ： 显示帮助画面，给出一些简短的命令总结说明<br>k ： 终止一个进程。系统将提示用户输入需要终止的进程PID<br>d ： 改变命令的刷新时间（默认为3s），系统将提示用户输入新的刷新时间<br>q ： 退出程序</p>
</li>
</ul>
<h3 id="free：内存使用"><a href="#free：内存使用" class="headerlink" title="free：内存使用"></a>free：内存使用</h3><ul>
<li><p>命令使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ free -m</div><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:           256        142        113          2          0         30</div><div class="line">-/+ buffers/cache:        112        143</div><div class="line">Swap:          128         22        105</div></pre></td></tr></table></figure>
</li>
<li><p>参数参考<br>-b 　以Byte为单位显示内存使用情况<br>-k 　以KB为单位显示内存使用情况<br>-m 　以MB为单位显示内存使用情况<br>-g   以GB为单位显示内存使用情况<br>-s&lt;间隔秒数&gt; 　持续观察内存使用状况</p>
</li>
<li>结果说明</li>
</ul>
<ol>
<li>第一行:<br>total 内存总数: 256M<br>used 已经使用的内存数: 142M<br>free 空闲的内存数: 113M<br>shared 共享内存数：2M<br>buffers Buffer 缓存内存数: 0M<br>cached Page 缓存内存数:30M<br>关系：total= used + free</li>
<li>第二行：<br>(-buffers/cache) used内存数：112M (指的第一部分Mem行中的used - buffers - cached)<br>(+buffers/cache) free内存数: 143M (指的第一部分Mem行中的free + buffers + cached)<br>可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数。</li>
<li>第三行：<br>交换区(虚拟内存)的使用情况，大家都能看懂</li>
</ol>
<h3 id="ps：进程使用"><a href="#ps：进程使用" class="headerlink" title="ps：进程使用"></a>ps：进程使用</h3><p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。kill 命令用于杀死进程。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ps</div><div class="line">  PID TTY          TIME CMD</div><div class="line">16307 pts/1    00:00:00 bash</div><div class="line">16468 pts/1    00:00:00 ps</div><div class="line">$ ps -ef		<span class="comment">#显示所有进程，包含命令行</span></div><div class="line">$ ps -aux		<span class="comment">#显示所有进程，包含其他使用者</span></div><div class="line">$ ps -C init		<span class="comment">#过滤只含有init命令的进程</span></div><div class="line">$ ps -axjf		<span class="comment">#树形显示进程</span></div><div class="line">$ ps -ef | grep <span class="string">"tomcat"</span>		<span class="comment">#查找本机正在运行的tomcat进程</span></div></pre></td></tr></table></figure></p>
<h3 id="kill：杀死进程"><a href="#kill：杀死进程" class="headerlink" title="kill：杀死进程"></a>kill：杀死进程</h3><p>kill命令其实是给指定进程发送一个指定信号来终止这个进程。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">kill</span> <span class="_">-l</span>		<span class="comment">#显示出所有进程的信号</span></div><div class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</div><div class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</div><div class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</div><div class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</div><div class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</div><div class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</div><div class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</div><div class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</div><div class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</div><div class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</div><div class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</div><div class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</div><div class="line">63) SIGRTMAX-1  64) SIGRTMAX</div><div class="line">$ <span class="built_in">kill</span> 123		<span class="comment">#杀掉pid为123的进程，默认发送15信号，进程在收到这个信号后会清理并释放资源。等同于在前台运行pid为123的进程，然后按下Ctrl+C键</span></div><div class="line">$ <span class="built_in">kill</span> -9 123		<span class="comment">#强制杀掉pid为123的进程，发送9信号。9是最强硬的杀掉信号，比其他kill信号等级都要高</span></div></pre></td></tr></table></figure></p>
<h3 id="date：日期"><a href="#date：日期" class="headerlink" title="date：日期"></a>date：日期</h3><p>date命令可以用各种格式来表现时间，也可以设定系统时间，也可以计算前后日期，此处不列举<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date</div><div class="line">Fri Sep  2 00:07:17 EDT 2016</div></pre></td></tr></table></figure></p>
<h3 id="cal：日历"><a href="#cal：日历" class="headerlink" title="cal：日历"></a>cal：日历</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cal			<span class="comment">#显示日历，当前年月</span></div><div class="line">$ cal 2016		<span class="comment">#显示2016年所有月的日历</span></div><div class="line">$ cal 10 2016		<span class="comment">#显示2016年10月的日历</span></div></pre></td></tr></table></figure>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>用户权限管理就是 以组来区分开用户，然后再给每个组辅以响应的操作空间、操作权限就完成了权限大业。</p>
<h3 id="who：登录用户"><a href="#who：登录用户" class="headerlink" title="who：登录用户"></a>who：登录用户</h3><p>显示目前登入系统的用户信息，与who am i一致。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ who			<span class="comment">#简单显示当前登录用户信息</span></div><div class="line">$ who <span class="_">-a</span>H		<span class="comment">#-a获取所有登录用户，-H列出表头</span></div><div class="line">$ whoami		<span class="comment">#仅仅显示当前登录用户的用户名</span></div></pre></td></tr></table></figure></p>
<h3 id="三个文件"><a href="#三个文件" class="headerlink" title="三个文件"></a>三个文件</h3><h4 id="用户信息：-etc-passwd"><a href="#用户信息：-etc-passwd" class="headerlink" title="用户信息：/etc/passwd"></a>用户信息：/etc/passwd</h4><p>我们首先看第一行root这一行，一共有七项，每一项使用：分开，他们代表的意思如下：</p>
<ol>
<li>帐号名称：帐号名称由于对应用户ID，这个是系统默认用户root超级管理员，在同一个系统帐号名称是唯一的，长度根据不同的linux系统而定，一般是8位。</li>
<li>密码：由于系统中还有一个/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。</li>
<li>用户ID：这个是系统内部用于来识别不同的用户的，不同的用户识别码不同，其中用户ID有以下几种：0代表系统管理员，如果你想建立一个系统管理员的话，可以建立一个普通帐户，然后将该账户的用户ID改为0即可。<br>1-500系统预留的ID，500以上是普通用户使用。</li>
<li>组ID：其实这个和用户ID功能差不多，用来规范群组，与/etc/group有关。</li>
<li>描述信息：这个字段几乎没有什么作用，只是用来解释这个帐号的意义。</li>
<li>用户根目录：就是用户登录系统的起始目录，用户登录系统后将首先进入该目录。root用户默认的是/root，普通用户的是/home/用户名。</li>
<li>用户登录shell：就是用户登录系统时使用的shell，关于shell我们会在以后专门的研究一下。<h4 id="用户密码信息：-etc-shadow"><a href="#用户密码信息：-etc-shadow" class="headerlink" title="用户密码信息：/etc/shadow"></a>用户密码信息：/etc/shadow</h4>在早期的unix操作系统中，用户的帐号信息和口令信息都保存在passwd文件中，尽管系统已经对口令进行了加密，并且以密文的方式保存在passwd文件中，但是由于passwd文件对于系统中的所有用户是可读的，口令比较容易破解，存在较大的安全隐患。现在使用“shadow”文件保存密文的用户口令，使用passwd文件保存用户帐号其它信息。“shadow”文件只有管理员用户才可以读取其中的内容。由于这个文件可能被破解，所以一定不要将该文件内容泄露给他人，保证系统安全。</li>
</ol>
<p>分析第一行，一共有九项，分别说明一下：</p>
<ol>
<li>帐户名称</li>
<li>密码：这才是真正的密码，并且已经加密过了，只能看到一些特殊符号。需要注意的是这些密码很难破解，但是不等于不能。还有密码栏的第一个字符为“*”表示这个用户不用来登录，如果那个用户不想让他登录了，可以在他前面加个星。</li>
<li>上次改动密码的日期：这段记录了改动密码的最后日期，为什么是16293呢？这是因为linux计算日期的方法是以1970年1月1日作为1，1971年1月1日就是366，依次类推到我修改密码的日期表示为16293了。</li>
<li>密码不可改的天数：假如这个数字是8，则8天内不可改密码，如果是0，则随时可以改</li>
<li>密码需要修改的期限：如果是99999则永远不用改。如果是其其他数字比如12345，那么必须在距离1970-1-1的12345天内修改密码，否则密码失效。 </li>
<li>密码变更期期限快到前的警告期：当帐号的密码失效期限快到时，系统依据这个字段的设定发出警告，提醒用户“再过n天您的密码将过期，请尽快重新设定密码。默认的是七天。</li>
<li>帐号失效期：如果用户过了警告期没有重新输入密码，使得密码失效，而该用户在这个字段限定的时间内又没有向管理员反映，让帐号重新启用，那么这个帐号将暂时失效。</li>
<li>帐号取消日期：这个日期跟第三个字段一样，都是使用1970年以来的日期设定方法。这个字段表示：这个帐号在此字段规定的日期之后将无法再使用。这个字段通常用于收费服务系统中，可以规定一个日期让该帐号不能再使用。</li>
<li>保留：最后一个字段是保留的，看以后有没有新功能加入。  <h4 id="组信息：-etc-group"><a href="#组信息：-etc-group" class="headerlink" title="组信息：/etc/group"></a>组信息：/etc/group</h4>每行4项：</li>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组id”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。<h3 id="groupadd：增加组"><a href="#groupadd：增加组" class="headerlink" title="groupadd：增加组"></a>groupadd：增加组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ groupadd <span class="built_in">test</span>			<span class="comment">#创建一个test组</span></div><div class="line">$ cat /etc/group | grep <span class="built_in">test</span>	<span class="comment">#查看一下刚刚创建的组</span></div><div class="line"><span class="built_in">test</span>:x:1002:</div><div class="line">$ groupadd --g 2000 student	<span class="comment">#指定组的gid</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="groupdel：删除组"><a href="#groupdel：删除组" class="headerlink" title="groupdel：删除组"></a>groupdel：删除组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ groupdel <span class="built_in">test</span>		<span class="comment">#删除test组</span></div></pre></td></tr></table></figure>
<h3 id="useradd：增加用户"><a href="#useradd：增加用户" class="headerlink" title="useradd：增加用户"></a>useradd：增加用户</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ useradd user1			<span class="comment">#创建用户user1，默认用户主目录为/home/用户名，此处为/home/user1</span></div><div class="line">$ useradd <span class="_">-d</span> /home/mytest <span class="built_in">test</span>	<span class="comment">#创建用户test，指定主目录为/home/mytest</span></div><div class="line">$ useradd <span class="_">-s</span> /bin/<span class="literal">false</span> user1	<span class="comment">#指定用户的shell为/bin/false</span></div><div class="line">$ useradd -g user user1		<span class="comment">#创建用户user1，指定其组为user</span></div></pre></td></tr></table></figure>
<p>此时创建的用户均没有登录密码，应紧接着设置其登录密码</p>
<h3 id="passwd：修改密码"><a href="#passwd：修改密码" class="headerlink" title="passwd：修改密码"></a>passwd：修改密码</h3><p>普通用户仅能修改自己的密码，root管理员可以修改普通用户和自己的密码<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ passwd		<span class="comment">#修改当前登录用户的密码</span></div><div class="line">$ passwd user1		<span class="comment">#修改用户user1的密码</span></div></pre></td></tr></table></figure></p>
<h3 id="usermod：修改用户"><a href="#usermod：修改用户" class="headerlink" title="usermod：修改用户"></a>usermod：修改用户</h3><p>除了本命令，直接修改/etc/passwd文件也可以达到效果<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ usermod -g <span class="built_in">test</span> user1				<span class="comment">#修改用户user1的组为test</span></div><div class="line">$ usermod -G staff newuser2			<span class="comment">#添加用户user1到组staff，同一个用户可以在多个组</span></div><div class="line">$ usermod <span class="_">-d</span> /home/myuser1 user1		<span class="comment">#修改用户user1的主目录为/home/myuser1</span></div><div class="line">$ usermod <span class="_">-s</span> /bin/sbin	user1			<span class="comment">#修改用户user1的shell为/bin/sbin</span></div><div class="line">$ usermod -L user1					<span class="comment">#锁定用户user1</span></div><div class="line">$ usermod -U user1					<span class="comment">#解锁用户user1</span></div></pre></td></tr></table></figure></p>
<h3 id="userdel：删除用户"><a href="#userdel：删除用户" class="headerlink" title="userdel：删除用户"></a>userdel：删除用户</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ userdel user1</div></pre></td></tr></table></figure>
<h3 id="umask：规定默认权限"><a href="#umask：规定默认权限" class="headerlink" title="umask：规定默认权限"></a>umask：规定默认权限</h3><p>umask总共为4位（gid/uid,属主，组权，其它用户的权限），第一位经常不看，看后三位。<br>默认情况下的umask值是022(可以用umask命令查看），此时你建立的文件默认权限是644(6-0,6-2,6-2)，建立的目录的默认权限是755(7-0,7-2,7-2)，这就是umask的作用。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">umask</span>			<span class="comment">#查看当前umask值</span></div><div class="line">$ <span class="built_in">umask</span> 002		<span class="comment">#修改mask值</span></div></pre></td></tr></table></figure></p>
<h3 id="chown：改变文件拥有者"><a href="#chown：改变文件拥有者" class="headerlink" title="chown：改变文件拥有者"></a>chown：改变文件拥有者</h3><p>管理员可以更改文件的拥有者和群组，通过控制权限来保证服务安全<br>参数：<br>-R 处理指定目录以及其子目录下的所有文件<br>-v 显示详细的处理信息<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ chown root:mail <span class="built_in">log</span>2012.log		<span class="comment">#改变log2012.log的拥有者和群组分别为root和mail</span></div><div class="line">$ chown root:	<span class="built_in">log</span>2012.log		<span class="comment">#改变log2012.log的拥有者为root，群组为root所在的群组</span></div><div class="line">$ chown :mail	<span class="built_in">log</span>2012.log		<span class="comment">#改变log2012.log的群组为mail</span></div></pre></td></tr></table></figure></p>
<h3 id="chmod：改变文件属性"><a href="#chmod：改变文件属性" class="headerlink" title="chmod：改变文件属性"></a>chmod：改变文件属性</h3><p>linux文件权限分为文件拥有者(user)、群组(group)、其他(other)。</p>
<p>设定权限模式为：[ugoa…][[+-=][rwxX]…][,…]<br>其中u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。<br>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被<br>设定过为可执行。 </p>
<p>此外chmod也可以用数字来表示权限如 chmod 777 file<br>语法为：chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。<br>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=7。 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ chmod ugo+r file1.txt		<span class="comment">#将 file1.txt 设为所有人皆可读取</span></div><div class="line">$ chmod a+r file1.txt		<span class="comment">#同上</span></div><div class="line">$ chmod u+x ex1.py		<span class="comment">#将 ex1.py 设定为只有该文件拥有者可以执行</span></div><div class="line">$ chmod -R a+r *		<span class="comment">#将目前目录下的所有档案与子目录皆设为任何人可读取</span></div><div class="line">$ chmod 777 file		<span class="comment">#所有人拥有所有权限</span></div><div class="line">$ chmod a=rwx fil		<span class="comment">#同上</span></div></pre></td></tr></table></figure>
<h2 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h2><h3 id="ifconfig：网卡查看"><a href="#ifconfig：网卡查看" class="headerlink" title="ifconfig：网卡查看"></a>ifconfig：网卡查看</h3><p>同windows下的ipconfig，另外可以创建网卡，更改mac，ip等</p>
<h3 id="ping：ping"><a href="#ping：ping" class="headerlink" title="ping：ping"></a>ping：ping</h3><p>同windows下的ping</p>
<h3 id="route：路由查看"><a href="#route：路由查看" class="headerlink" title="route：路由查看"></a>route：路由查看</h3><p>route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是 为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为 Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；要想永久保存，有如下方法：</p>
<ol>
<li>在/etc/rc.local里添加</li>
<li>在/etc/sysconfig/network里添加到末尾</li>
<li>/etc/sysconfig/static-router : any net x.x.x.x/24 gw y.y.y.y</li>
</ol>
<p>本命令使用需要一定的网络知识</p>
<h3 id="wget：下载"><a href="#wget：下载" class="headerlink" title="wget：下载"></a>wget：下载</h3><p>还支持限速下载，断点续传，后台下载等很多功能<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip	<span class="comment">#下载某个文件</span></div></pre></td></tr></table></figure></p>
<h3 id="curl：命令浏览器"><a href="#curl：命令浏览器" class="headerlink" title="curl：命令浏览器"></a>curl：命令浏览器</h3><p>非常强大，此处不详细讲<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl http://www.linux.com			<span class="comment">#网页文件内容就显示在屏幕上了</span></div><div class="line">$ curl http://www.linux.com &gt;&gt; linux.html	<span class="comment">#保存某个面</span></div></pre></td></tr></table></figure></p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="df：disk-free"><a href="#df：disk-free" class="headerlink" title="df：disk free"></a>df：disk free</h3><p>通过文件系统来快速获取空间大小的信息，当我们删除一个文件的时候，这个文件不是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规则释放掉已经删除的文件， df记录的是通过文件系统获取到的文件的大小，他比du强的地方就是能够看到已经删除的文件，而且计算大小的时候，把这一部分的空间也加上了，更精确了。</p>
<h3 id="du：disk-usage"><a href="#du：disk-usage" class="headerlink" title="du：disk usage"></a>du：disk usage</h3><p>是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ du		<span class="comment">#显示当前目录和文件所占空间，最后一个是总大小</span></div><div class="line">$ du file	<span class="comment">#显示file文件所占空间</span></div><div class="line">$ du dir	<span class="comment">#显示dir目录及目录下内容所占空间</span></div><div class="line">$ du -h		<span class="comment">#用方便阅读的方式显示</span></div></pre></td></tr></table></figure></p>
<h3 id="fdisk：查看分区"><a href="#fdisk：查看分区" class="headerlink" title="fdisk：查看分区"></a>fdisk：查看分区</h3><p>可以列出所有的分区,包括没有挂上的分区和usb设备.我一般用这个来查找需要挂载的分区的位置,比如挂上u盘。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fdisk <span class="_">-l</span></div></pre></td></tr></table></figure></p>
<h3 id="mount：挂载"><a href="#mount：挂载" class="headerlink" title="mount：挂载"></a>mount：挂载</h3><p>使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享等<br>示例：挂载u盘<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ fdisk <span class="_">-l</span>					<span class="comment">#查看当前的分区结构，然后插入u盘</span></div><div class="line">$ fdisk <span class="_">-l</span>					<span class="comment">#查看当前的分区结构，看看多出了那个设备</span></div><div class="line">$ mkdir /mnt/usb				<span class="comment">#创建一个文件夹</span></div><div class="line">$ mount /dev/sdd1 /mnt/usb			<span class="comment">#将这个设备挂载在文件夹上</span></div></pre></td></tr></table></figure></p>
<h3 id="umount：解除挂载"><a href="#umount：解除挂载" class="headerlink" title="umount：解除挂载"></a>umount：解除挂载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ umount /mnt/usb</div></pre></td></tr></table></figure>
<h2 id="备份压缩"><a href="#备份压缩" class="headerlink" title="备份压缩"></a>备份压缩</h2><h3 id="gzip：-gz"><a href="#gzip：-gz" class="headerlink" title="gzip：.gz"></a>gzip：.gz</h3><p>处理尾缀是.gz的压缩文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gzip FileName		<span class="comment">#压缩</span></div><div class="line"></div><div class="line">$ gunzip FileName.gz	<span class="comment">#解压</span></div><div class="line">$ gzip <span class="_">-d</span> FileName.gz	<span class="comment">#解压</span></div></pre></td></tr></table></figure></p>
<h3 id="bzip：-bz"><a href="#bzip：-bz" class="headerlink" title="bzip：.bz"></a>bzip：.bz</h3><p>处理尾缀是.bz的压缩文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bzip2 <span class="_">-d</span> FileName.bz	<span class="comment">#解压</span></div><div class="line">$ bunzip2 FileName.bz	<span class="comment">#解压</span></div></pre></td></tr></table></figure></p>
<h3 id="bzip2：-bz2"><a href="#bzip2：-bz2" class="headerlink" title="bzip2：.bz2"></a>bzip2：.bz2</h3><p>处理尾缀是.bz2的压缩文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ bzip2 -z FileName	<span class="comment">#压缩</span></div><div class="line"></div><div class="line">$ bzip2 <span class="_">-d</span> FileName.bz2	<span class="comment">#解压</span></div><div class="line">$ bunzip2 FileName.bz2	<span class="comment">#解压</span></div></pre></td></tr></table></figure></p>
<h3 id="compress：-Z"><a href="#compress：-Z" class="headerlink" title="compress：.Z"></a>compress：.Z</h3><p>处理尾缀是.Z的压缩文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ compress FileName	<span class="comment">#压缩</span></div><div class="line"></div><div class="line">$ uncompress FileName.Z	<span class="comment">#解压</span></div></pre></td></tr></table></figure></p>
<h3 id="tar：-tar重要"><a href="#tar：-tar重要" class="headerlink" title="tar：.tar重要"></a>tar：.tar重要</h3><p>处理尾缀包含.tar的压缩文件，因为大部分linux平台的压缩文件包含.tar，然后用tar命令即可处理这些解压缩问题<br>参数：</p>
<blockquote>
<p>几个互斥的必输操作参数，这几个命令只能选一个：<br>-c: 建立压缩档案<br>  -x：解压<br>  -t：查看内容<br>  -r：向压缩归档文件末尾追加文件<br>  -u：更新原压缩包中的文件<br>必输参数： -f 这个参数是最后一个参数，后面只能接档案名<br>可选参数：<br>-z：有gzip属性的<br>  -j：有bz2属性的<br>  -Z：有compress属性的<br>  -v：显示所有过程</p>
</blockquote>
<p>示例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ tar -cf all.tar *.jpg		<span class="comment">#将所有.jpg的文件打成一个名为all.tar的包</span></div><div class="line">$ tar -rf all.tar *.gif		<span class="comment">#将所有.gif的文件增加到all.tar的包里面去</span></div><div class="line">$ tar -uf all.tar logo.gif 	<span class="comment">#更新原来tar包all.tar中logo.gif文件</span></div><div class="line">$ tar -tf all.tar		<span class="comment">#列出all.tar包中所有文件</span></div><div class="line">$ tar -xf all.tar		<span class="comment">#解出all.tar包中所有文件</span></div><div class="line">$ tar -rf all.tar *.gif		<span class="comment">#将所有.gif的文件增加到all.tar的包里面去</span></div><div class="line"></div><div class="line"><span class="comment">#配合其他压缩方式</span></div><div class="line">tar –cvf jpg.tar *.jpg 		<span class="comment">#将目录里所有jpg文件打包成tar.jpg </span></div><div class="line">tar –czf jpg.tar.gz *.jpg	<span class="comment">#将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz </span></div><div class="line">tar –cjf jpg.tar.bz2 *.jpg	<span class="comment">#将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 </span></div><div class="line">tar –cZf jpg.tar.Z *.jpg	<span class="comment">#将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z </span></div><div class="line"></div><div class="line"><span class="comment">#解压 双重压缩的文件</span></div><div class="line">tar –xvf file.tar		<span class="comment">#解压 tar包 </span></div><div class="line">tar -xzvf file.tar.gz		<span class="comment">#解压tar.gz </span></div><div class="line">tar -xjvf file.tar.bz2		<span class="comment">#解压 tar.bz2 </span></div><div class="line">tar –xZvf file.tar.Z		<span class="comment">#解压tar.Z</span></div></pre></td></tr></table></figure></p>
<h3 id="zip-unzip：-zip"><a href="#zip-unzip：-zip" class="headerlink" title="zip/unzip：.zip"></a>zip/unzip：.zip</h3><p>处理尾缀是.zip的压缩文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ zip -r myfile.zip ./*		<span class="comment">#将当前目录下的所有文件压缩到myfile.zip文件中，-r递归压缩子目录下所有文件,常用</span></div><div class="line">$ zip <span class="_">-d</span> myfile.zip smart.txt	<span class="comment">#删除压缩文件中smart.txt文件</span></div><div class="line">$ zip -m myfile.zip ./add.txt	<span class="comment">#向压缩文件中myfile.zip中添加add.txt文件</span></div><div class="line"><span class="comment">#file1、file2、 file3、以及 /usr/work/school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中:</span></div><div class="line">$ zip -r filename.zip file1 file2 file3 /usr/work/school</div><div class="line"></div><div class="line"></div><div class="line">$ unzip myfile.zip				<span class="comment">#解压myfile.zip到当前文件夹下</span></div><div class="line">$ unzip <span class="_">-d</span> /home/root myfile.zip		<span class="comment">#解压myfile.zip到/home/root下</span></div></pre></td></tr></table></figure></p>
<p>终于写完了，断断续续写了这么长时间，不过也收益良多，温故而知新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux操作系统在开发部署过程中太常用了，一个优秀的开发者肯定会熟练使用它的。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://xuea.github.io/categories/linux/"/>
    
    
      <category term="linux命令" scheme="https://xuea.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="总结" scheme="https://xuea.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>文件搜索神器Everything的使用</title>
    <link href="https://xuea.github.io/2016/08/19/%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%A5%87Everything%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xuea.github.io/2016/08/19/文件搜索神奇Everything的使用/</id>
    <published>2016-08-19T02:04:07.000Z</published>
    <updated>2016-08-19T13:14:54.617Z</updated>
    
    <content type="html"><![CDATA[<p>Everything是windows下的文件搜索神器，它体积小、速度快、功能强大，相比于windows自带的文件查找工具，速度简直可以上天了，所以它深得大家的喜爱。我在此分享自己使用过程中的小技巧，相信大家看了会豁然开朗，工作效率又提升一大截。<br><a id="more"></a></p>
<h2 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载&amp;安装"></a>下载&amp;安装</h2><p>选择好相应的版本，x86是32位操作系统用的，x64是64位操作系统用的，带有Multilingual字样的是多语言版本(包含中文):<br><a href="http://www.voidtools.com/downloads/" target="_blank" rel="external">下载地址</a></p>
<p>安装过程是中文，我选择了如下会出现的选项，读者请自行选择。</p>
<ul>
<li>随系统自启动</li>
<li>以管理员身份运行</li>
<li>保存设置和数据文件到：安装文件夹</li>
<li>集成到资源管理器右键菜单，可以在目录右键，搜索本目录下的文件</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>第一次打开软件，可能运行有点慢，因为软件要为系统文件建立索引。</p>
<p>打开 工具-常规-快捷键，将“切换窗口快捷键”设置为自己喜欢的快捷键，我设置的为：Ctrl+Alt+F。此时，一按快捷键就出现，按一个Esc键就隐去，感觉挺爽</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="逻辑词"><a href="#逻辑词" class="headerlink" title="逻辑词"></a>逻辑词</h3><ul>
<li>空格：与关系</li>
<li>|：或关系</li>
<li>!：非关系</li>
</ul>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul>
<li>*：匹配0到多个字符</li>
<li>?：匹配一个字符</li>
</ul>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li>“dupe:”：查询重复为文件名</li>
<li>“empty:”：查询空目录</li>
<li>“len:<length>“：查询长度为length的文件名和文件夹名</length></li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">abc			<span class="comment">#所有包含abc字母的文件和文件夹</span></div><div class="line">F: *.jpg		<span class="comment">#f盘下面所有的jpg文件(与关系应用)</span></div><div class="line">*.avi|*.mp4		<span class="comment">#所有的avi文件和MP4文件(或关系应用)</span></div><div class="line">dupe:*.avi		<span class="comment">#本系统所有重复的avi文件，可以用来删除没必要的重复文件</span></div><div class="line">enpty:			<span class="comment">#本系统所有的空文件夹</span></div><div class="line">len:&gt;7			<span class="comment">#文件名和文件夹名长度大于7的文件列表</span></div></pre></td></tr></table></figure>
<p>最后，如果你还想更进一步了解查找的精华：<a href="http://www.voidtools.com/support/everything/searching/" target="_blank" rel="external">查找详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Everything是windows下的文件搜索神器，它体积小、速度快、功能强大，相比于windows自带的文件查找工具，速度简直可以上天了，所以它深得大家的喜爱。我在此分享自己使用过程中的小技巧，相信大家看了会豁然开朗，工作效率又提升一大截。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://xuea.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://xuea.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="技巧" scheme="https://xuea.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>CentOS搭建meanjs环境(二)</title>
    <link href="https://xuea.github.io/2016/08/07/CentOS%E6%90%AD%E5%BB%BAmeanjs%E7%8E%AF%E5%A2%83-%E4%BA%8C/"/>
    <id>https://xuea.github.io/2016/08/07/CentOS搭建meanjs环境-二/</id>
    <published>2016-08-07T01:39:50.000Z</published>
    <updated>2016-08-13T07:26:28.442Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="../../06/CentOS搭建meanjs环境-一">CentOS搭建meanjs环境(一)</a>中已经整体上介绍了mean这个技术栈的情况，接下来我们就开始实际搭建出来meanjs的环境：</p>
<a id="more"></a>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本次搭建meanjs环境是以<a href="http://meanjs.org/" target="_blank" rel="external">meanjs官网</a>中的<a href="http://meanjs.org/docs.html" target="_blank" rel="external">文档</a>为主要路线，然后辅以相应的知识扩展，基本操作，问题解决处理。</p>
<p>本人的搭建环境是 CentOS6 x86，几乎是个白板操作系统，所以遇到的问题可能是大家都会遇到的。</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>此处安装git主要用于克隆meanjs的源代码，大部分电脑可能有，那就跳过这一步。此处为CentOS系统的安装方法，其他操作系统请参考<a href="https://git-scm.com/downloads" target="_blank" rel="external">https://git-scm.com/downloads</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git --version 	<span class="comment">#检测是否已经安装git</span></div><div class="line">$ yum update 		<span class="comment">#更新yum的软件库</span></div><div class="line">$ yum install git 	<span class="comment">#安装git</span></div></pre></td></tr></table></figure>
<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><p>鉴于nodejs社区非常活跃，版本更新迭代速度快的问题，我们可以采用 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> 和 <a href="https://github.com/tj/n" target="_blank" rel="external">n</a> 来管理nodejs的版本，此处我采用nvm，因为n还需要首先得安装一个nodejs环境，这是个 鸡生蛋还是蛋生鸡 的问题，比较头大。</p>
<p>可以用<strong>curl或者wget</strong>命令来安装nvm：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash</div><div class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash</div></pre></td></tr></table></figure>
<p>完成之后，出现“close your terminal and 。。。”，忘记记下来了，大致意思就是：关闭你的控制台再启动，你就可以使用nvm了。然后就关闭控制台，再开启一次，果然OK。（突然反应过来，此时输入   $ source ~/.bashrc 应该就可以，不用重启控制台啊）</p>
<p>接下来，介绍nvm的常用命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ nvm --version		<span class="comment">#检查nvm的版本号，来检查是否安装成功</span></div><div class="line">$ nvm install 4.4.7	<span class="comment">#下载、安装并且编译版本为4.4.7的nodejs</span></div><div class="line">$ nvm install 6.3.1	<span class="comment">#下载、安装并且编译版本为6.3.1的nodejs</span></div><div class="line">$ nvm uninstall 4.4.7	<span class="comment">#卸载版本为4.4.7的nodejs</span></div><div class="line">$ nvm current		<span class="comment">#查看当前使用的nodejs版本</span></div><div class="line">$ nvm ls		<span class="comment">#显示所有nodejs版本</span></div><div class="line">$ nvm use 4.4.7		<span class="comment">#使用版本为4.4.7的nodejs</span></div></pre></td></tr></table></figure>
<h2 id="node-amp-npm"><a href="#node-amp-npm" class="headerlink" title="node &amp; npm"></a>node &amp; npm</h2><p>经过nvm的安装之后，你应该已经选好了自己要用的node版本了(node会自带npm的安装)，用下面的命令来看看是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node --version</div><div class="line">$ npm --version</div></pre></td></tr></table></figure>
<p>npm主要是用来方便快捷的使用node第三方包的，项目中会经常使用，此处介绍npm的常用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ npm install npm -g    		#更新npm</div><div class="line">$ npm install				#根据当前项目下的 package.json 文件下载对应的包</div><div class="line">$ npm install &lt;Module Name&gt; -g		#全局安装模块，Module Name方的是模块名，-g是全局安装</div><div class="line">$ npm install &lt;Module Name&gt;  --save-dev/--save</div><div class="line">##上一条命令的解释 start	</div><div class="line">#没有-g就是当前项目下安装某个模块。--save和--save-dev是自动将安装的内容配置到 package.json，省去了手动输入的麻烦。 </div><div class="line">#--save自动把模块和版本号添加到dependencies部分， --save-dve自动把模块和版本号添加到devdependencies部分。</div><div class="line">#至于配置文件区分这俩部分， 是用于区别产品依赖模块(dependencies)和开发依赖模块(devdependencies)， 以我见过的情况来看 devDepandencies主要是配置测试框架， 例如jshint、mocha</div><div class="line">##上一条命令的解释 end</div><div class="line">$ npm ls -g				#查看全局安装了哪些模块，不加-g就是当前项目安装了哪些模块</div><div class="line">$ npm ls &lt;Module Name&gt; -g		#查看全局安装的某个模块的情况，不加-g就不解释了</div><div class="line">$ npm uninstall &lt;Module Name&gt; -g	#全局卸载某一模块，不加-g就不解释了</div><div class="line">$ npm update &lt;Module Name&gt; -g 		#全局更新某一模块，不加-g就不解释了</div><div class="line">$ npm init        			#初始化模块，npm会根据当前项目下 package.json 文件来下载需要的模块，package.json里面配置了项目依赖的模块</div></pre></td></tr></table></figure>
<p>接下来，我们来介绍几个常用的模块：</p>
<ul>
<li><p><a href="https://bower.io/" target="_blank" rel="external">bower</a>：网站是由框架、模块包、图片资源、音视频资源和工具等很多内容组成的，Bower来管理这些内容。它本来考虑的是全局管理所有资源，但是我们通常用它管理客户端的资源，比如jquery、bootstrap、前端图片等等。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ npm install bower -g		<span class="comment">#全局安装bower</span></div><div class="line"><span class="comment">#下面是bower常用命令，可能需要--allow-root临时获取root权限，在命令后面加上 --allow-root 即可使用</span></div><div class="line">$ bower init 			<span class="comment">#进入项目目录下，会创建一个bower.json文件，里面保存了项目的配置信息</span></div><div class="line">$ bower install		 	<span class="comment">#根据当前项目目录下的bower.json文件安装所需要的包，</span></div><div class="line">$ bower install jquery --save 	<span class="comment">#自动安装最新的jquery，--save是将配置信息自动保存到bower.json文件中。jquery可替换成其他需要的文件</span></div><div class="line">$ bower info jquery		<span class="comment">#查看jquery的版本信息等。jquery可替换成其他需要的文件</span></div><div class="line">$ bower update			<span class="comment">#bower.json文件修改后，更新命令可以相应的下载所需的包	</span></div><div class="line">$ bower search bootstrap	<span class="comment">#可以查找所有包含bootstrap字符的包。bootstrap可替换成其他所需要查找的字符</span></div><div class="line">$ bower uninstall jquery	<span class="comment">#卸载jquery。jquery可替换成其他需要的文件</span></div></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.gruntjs.net/" target="_blank" rel="external">grunt</a>：对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install grunt-cli -g		#全局安装grunt</div></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp</a>：功能上与上述的grunt是相互可替代的，相比而言，我认为gulp的api更加通俗易懂，容易使用。此处安装两个，是为了方便后续两个可以都试一试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install gulp -g			#全局安装gulp</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="http://www.mongodb.org/downloads" target="_blank" rel="external">各系统下载</a><br><a href="https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="external">安装指导</a></p>
<p>此处遇到坑，32位系统只能安装2.6版本，后续不支持32位系统了。此处说明：MongoDB不建议使用32位的操作系统，因为这样只能处理2GB大小的数据，而MongoDB是非常费空间的。</p>
<p>64位contos安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/yum.repos.d/mongodb-org-3.0.repo</div><div class="line"><span class="comment">#输入下列文字  start</span></div><div class="line">[mongodb-org-3.0]</div><div class="line">name=MongoDB Repository</div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/3.0/x86_64/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"><span class="comment">#输入下列文字  end</span></div><div class="line">$ sudo yum install -y mongodb-org</div></pre></td></tr></table></figure></p>
<p>32位centos安装<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/yum.repos.d/mongodb-org-3.0.repo    <span class="comment">#文件名可能有点不对应了，无所谓，一个标识而已</span></div><div class="line"><span class="comment">#输入下列文字  start</span></div><div class="line">[mongodb]</div><div class="line">name=MongoDB Repository</div><div class="line">baseurl=http://downloads-distro.mongodb.org/repo/redhat/os/i686/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"><span class="comment">#输入下列文字  end</span></div><div class="line">$ sudo yum install -y mongodb-org</div></pre></td></tr></table></figure></p>
<p>此时，mongodb已经安装完成了，我们做一些小修改，然后启动服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/mongod.conf</div><div class="line"># 将文件中的  port=27017   前的#去掉，保存后退出</div><div class="line">$ service mongod start			#启动服务</div><div class="line">$ tail /var/log/mongodb/mongod.log 	#查看mongodb日志，发现[initandlisten] waiting for connections on port &lt;port&gt;，表示服务已经在27017端口启动监听，启动成功</div></pre></td></tr></table></figure></p>
<p>推荐一个初步学习mongodb的网站：<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="external">MongoDB 教程</a></p>
<h2 id="克隆meanjs并运行"><a href="#克隆meanjs并运行" class="headerlink" title="克隆meanjs并运行"></a>克隆meanjs并运行</h2><h3 id="下载meanjs到meanjs目录中"><a href="#下载meanjs到meanjs目录中" class="headerlink" title="下载meanjs到meanjs目录中"></a>下载meanjs到meanjs目录中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/meanjs/mean.git meanjs</div></pre></td></tr></table></figure>
<p>或者用zip解压也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ wget https://github.com/meanjs/mean/archive/master.zip -O meanjs.zip</div><div class="line">$ unzip meanjs.zip</div><div class="line">$ rm meanjs.zip</div></pre></td></tr></table></figure></p>
<h3 id="安装所需模块"><a href="#安装所需模块" class="headerlink" title="安装所需模块"></a>安装所需模块</h3><p>进入meanjs目录下，安装所需的组件</p>
<p>我在此处使用了 <a href="https://npm.taobao.org/" target="_blank" rel="external">cnpm</a>，即中国的npm来安装这些包，是由淘宝提供的，可信度还是不错的。cnpm的使用与npm的使用方法一致，只是将命令 npm  变为 cnpm 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org		#全局安装cnpm</div><div class="line">$ cd meanjs</div><div class="line">$ cnpm install</div></pre></td></tr></table></figure></p>
<h3 id="安装前端内容"><a href="#安装前端内容" class="headerlink" title="安装前端内容"></a>安装前端内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bower install --allow-root</div></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>使用 <strong>gulp或者grunt</strong> 来构建运行项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gulp</div><div class="line">#OR</div><div class="line">$ grunt</div></pre></td></tr></table></figure></p>
<ul>
<li><p>如出现报错：Error: Cannot find module ‘less’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g less --save-dev</div></pre></td></tr></table></figure>
</li>
<li><p>如出现报错：Error: ENOENT: no such file or directory, scandir ‘/usr/local/app/meanjs0.4.2/node_modules/.3.8.0@node-sass/vendor’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd node_modules</div><div class="line">$ npm rebuild node-sass</div><div class="line">$ cd ..</div></pre></td></tr></table></figure>
</li>
</ul>
<p>最后再试一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gulp</div><div class="line">#OR</div><div class="line">$ grunt</div></pre></td></tr></table></figure></p>
<blockquote>
<p>MEAN.JS - Development Environment<br>Environment:                    development<br>Port:                           3000<br>Database:                               mongodb://localhost/mean-dev<br>App version:                    0.4.2<br>MEAN.JS version:                        0.4.2</p>
</blockquote>
<p>出现类似上述文字即运行成功，打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a> 看看效果吧</p>
<hr>
<p>快速连接：</p>
<p><a href="../../06/CentOS搭建meanjs环境-一">CentOS搭建meanjs环境(一)</a><br><a href="#">CentOS搭建meanjs环境(二)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;../../06/CentOS搭建meanjs环境-一&quot;&gt;CentOS搭建meanjs环境(一)&lt;/a&gt;中已经整体上介绍了mean这个技术栈的情况，接下来我们就开始实际搭建出来meanjs的环境：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://xuea.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://xuea.github.io/tags/Javascript/"/>
    
      <category term="NodeJS" scheme="https://xuea.github.io/tags/NodeJS/"/>
    
      <category term="MEANJS" scheme="https://xuea.github.io/tags/MEANJS/"/>
    
      <category term="CentOS" scheme="https://xuea.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS搭建meanjs环境(一)</title>
    <link href="https://xuea.github.io/2016/08/06/CentOS%E6%90%AD%E5%BB%BAmeanjs%E7%8E%AF%E5%A2%83-%E4%B8%80/"/>
    <id>https://xuea.github.io/2016/08/06/CentOS搭建meanjs环境-一/</id>
    <published>2016-08-06T12:51:31.000Z</published>
    <updated>2016-08-13T06:55:41.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mean简介"><a href="#mean简介" class="headerlink" title="mean简介"></a>mean简介</h2><p>mean是一个以Javascript为基础的web全栈开发解决方案，mongodb为数据库，express为服务端框架，angularjs作为客户端框架，nodejs作为服务器运行环境，mean刚好就是四大组件的首字母拼合而成。</p>
<a id="more"></a>
<p>就跟LAMP、JAVAWEB一样，mean是一套完整的web开发解决方案，它潜力无限，有可能就是未来开发界的大趋势。对于公司来说：养一个全栈工程师，比养一个前端工程师+一个后端工程师相对成本会降低不少；对于个人来说：干的活的类型可能相对多一点，但省去一部分交流的麻烦，工作会更顺心。</p>
<h2 id="mean四大组件简介"><a href="#mean四大组件简介" class="headerlink" title="mean四大组件简介"></a>mean四大组件简介</h2><ul>
<li><p><a href="https://www.mongodb.com/" target="_blank" rel="external">mongoDB</a>：</p>
<ol>
<li>nosql，最流行的非关系型数据库之一</li>
<li>类似JSON的结构, 属于文档型数据库</li>
<li>数据库数据读取简单，速度快    </li>
<li>扩展性好，可以用在规模庞大的运行环境中</li>
<li>对于大数据量、高并发、弱事务的互联网应用，MongoDB则是一个如瑞士军刀般的利剑。</li>
</ol>
</li>
<li><p><a href="http://www.expressjs.com.cn/" target="_blank" rel="external">express</a>：</p>
<ol>
<li>基于nodejs的轻量级web应用框架    </li>
<li>封装了nodejs的http模块    </li>
<li>简单易用</li>
</ol>
</li>
<li><p><a href="http://www.apjs.net/" target="_blank" rel="external">angularjs</a>：</p>
<ol>
<li>前端mvvm框架，学会之后可以享受急速的开发快感（针对大部分是CURD业务的系统）</li>
<li>双向绑定（1.5开始同时支持单向绑定）</li>
<li>来自Google，稳定性和支持没问题</li>
</ol>
</li>
<li><p><a href="http://nodejs.cn/" target="_blank" rel="external">nodejs</a>：</p>
<ol>
<li>服务器Javascript运行平台，基于Chrome V8引擎   </li>
<li>I/O非阻塞，高并发尽管来吧</li>
<li>事件驱动，异步编程    </li>
<li>NPM包管理，造的好轮子大家一起用</li>
</ol>
</li>
</ul>
<h2 id="mean框架的优缺点"><a href="#mean框架的优缺点" class="headerlink" title="mean框架的优缺点"></a>mean框架的优缺点</h2><p><strong>优点：</strong></p>
<ol>
<li>一种语言(即Javascript)编写前后端逻辑，相同的语法和规范    </li>
<li>扩展性好</li>
<li>项目结构清晰，容易上手    </li>
<li>社区活跃</li>
<li>公司前后端开发交流无障碍，快速而便捷</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>mongoDB的<a href="https://docs.mongodb.com/manual/reference/limits/" target="_blank" rel="external">缺点</a>：<ul>
<li>不支持事务</li>
<li>没有熟悉的join（在设计表的时候得考虑多一点了）</li>
<li>相对mysql这样成熟的数据库来说，资料相对较少</li>
</ul>
</li>
<li>nodejs缺点：<ul>
<li>不适合大量运算型的任务，适合高并发任务</li>
<li>新手编程会遇到的坑比较多</li>
</ul>
</li>
</ol>
<p><em>当然，每个框架各有千秋，扬长避短才是正事</em></p>
<h2 id="目前两大mean实践方案"><a href="#目前两大mean实践方案" class="headerlink" title="目前两大mean实践方案"></a>目前两大mean实践方案</h2><p>MEAN.JS：<a href="https://github.com/meanjs/mean" target="_blank" rel="external">https://github.com/meanjs/mean</a></p>
<p>MEAN.IO：<a href="https://github.com/linnovate/mean" target="_blank" rel="external">https://github.com/linnovate/mean</a></p>
<blockquote>
<p><strong>MEAN.IO VS MEAN.JS</strong></p>
<ul>
<li>出自同一个开发组之手，各种理念原因分道扬镳。</li>
<li><strong>本质</strong>上是一样的：MongoDB+Express+AngularJS+Node.js</li>
<li><strong>共同技术</strong>：jQuery, Bootstrap, swig, mongoose, passport, karma和mocha, nodemon, bower </li>
<li><strong>项目新建的方式不同</strong>：MEAN.IO使用内置命令行工具mean；MEAN.JS使用Yeoman </li>
<li><strong>模块组织方式不同</strong>：MEAN.IO使用了node包管理方式，MEAN.JS使用的是前端模块管理方式 </li>
<li><strong>项目构建的方式不同</strong>：MEAN.IO使用gulp，MEAN.JS使用了grunt和gulp</li>
<li><strong>文档</strong>：MEAN.js更开放，文档更完善一些</li>
</ul>
</blockquote>
<p><em>最后，我选取的是MEAN.JS，萝卜青菜各有所爱。我只是更懒一点，哪个文档多我选哪个，哈哈。</em></p>
<p><strong>介绍的差不多啦，接下来开始搭建：<a href="../../07/CentOS搭建meanjs环境-二/">连接地址</a></strong></p>
<hr>
<p>快速连接：</p>
<p><a href="#">CentOS搭建meanjs环境(一)</a><br><a href="../../07/CentOS搭建meanjs环境-二/">CentOS搭建meanjs环境(二)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mean简介&quot;&gt;&lt;a href=&quot;#mean简介&quot; class=&quot;headerlink&quot; title=&quot;mean简介&quot;&gt;&lt;/a&gt;mean简介&lt;/h2&gt;&lt;p&gt;mean是一个以Javascript为基础的web全栈开发解决方案，mongodb为数据库，express为服务端框架，angularjs作为客户端框架，nodejs作为服务器运行环境，mean刚好就是四大组件的首字母拼合而成。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://xuea.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://xuea.github.io/tags/Javascript/"/>
    
      <category term="NodeJS" scheme="https://xuea.github.io/tags/NodeJS/"/>
    
      <category term="MEANJS" scheme="https://xuea.github.io/tags/MEANJS/"/>
    
      <category term="CentOS" scheme="https://xuea.github.io/tags/CentOS/"/>
    
  </entry>
  
</feed>
